# 编码规范

POJO规范：

- 数据对象：xxxDO ==对应数据库表==

- 数据传输对象：xxxDTO 数据传输之间使用

- 展示对象：xxxVO controller层接收和返回的就是RequstVO，ResponseVO

 [Java开发手册(黄山版).pdf](../../../Downloads/Java开发手册(黄山版).pdf) 

两者对象比较的时候，常量.equals(变量); 或者使用`java.utils.Objects的equals方法`。

浮点数之间的比较

- 基本数据类型不能直接用 == 比较
- 包装数据类型不能用equals比较
- 为什么？
  - 因为Java中浮点数存储的是有误差的，需要了解浮点数的存储结构

计算机中浮点数存储：

float32: 4个字节，也就是32bit，在Java中是32，但是不同语言可能有不同的定义。

32个bit，其中

- 1bit：符号位
- 8bit：指数位（存储的时候有偏置，原来的数要加上127偏置后存储）
- 23bit：尾数位

举例：20.625

20: 00010100

0.625：101

- 小数点往后的是2的-1次方，0.5，再往后是0.25...,所以0.625是0.5+0+0.125

20.625: 10100.101

通常表示的时候小数点要移到前面，1.0100101，相当于右移4位。

符号位：0

指数位：4+127（127是偏置）=131

- 二进制表示：128+2+1: 10000011

尾数位：小数点后面的值：0100101
20.625: 整体存储

- 0 10000011 0100101000000000000000

> 浮点数为什么不精确到这里应该明白了吧？

因为小数这样存储肯定有精度丢失的问题，比如0.4，存储的时候只能是0+0.25+0.125+0+0+...。

如果存储的小数可以被2的n次方这样相加的表示出来，就没有问题。比如0.625和0.125这种就可以被表示无误差。

这样设计的目的是为了表示其他某些数字。

Java中计算浮点数相关的用BigDecimal，并且通过传入字符串生成小数。